<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>3D Viewer</title>
<style>
  html,body{
    margin:0;
    height:100%;
    background:#111;
    color:#fff;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
    overflow:hidden;
  }

  #topbar{
    position:absolute;
    top:0;
    left:0;
    right:0;
    background:rgba(0,0,0,0.7);
    padding:.75rem 1rem;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    gap:.75rem;
    z-index:10;
    backdrop-filter:blur(6px);
    -webkit-backdrop-filter:blur(6px);
  }

  .btn{
    background:#2a2a2a;
    border:1px solid #444;
    border-radius:6px;
    padding:.6rem .8rem;
    font-size:.9rem;
    font-weight:500;
    color:#fff;
    line-height:1.2;
    cursor:pointer;
    -webkit-tap-highlight-color: rgba(255,255,255,0.2);
  }

  #status{
    font-size:.8rem;
    color:#9e9e9e;
    line-height:1.4;
    word-break:break-word;
    flex:1;
    min-width:200px;
    max-width:70%;
  }

  #canvasContainer{
    position:absolute;
    inset:0;
  }

  #help{
    position:absolute;
    left:.75rem;
    bottom:.75rem;
    background:rgba(0,0,0,0.6);
    color:#ccc;
    font-size:.7rem;
    line-height:1.4;
    padding:.5rem .6rem;
    border-radius:4px;
    border:1px solid rgba(255,255,255,0.1);
    z-index:10;
  }

  /*
    We keep the real file input in the DOM, not display:none,
    so iOS will allow it. We'll just visually shrink it.
    We'll trigger it from the button.
  */
  #fileWrapper {
    position:relative;
    width:0;
    height:0;
    overflow:hidden;
  }

  #fileInput{
    font-size:16px; /* iOS: avoid zoom */
    opacity:0;
    position:absolute;
    left:0;
    top:0;
    width:1px;
    height:1px;
  }
</style>
</head>
<body>

<div id="topbar">
  <button id="chooseBtn" class="btn">Choose 3D file</button>
  <div id="status">No file loaded</div>
  <div id="fileWrapper">
    <input id="fileInput" type="file" />
  </div>
</div>

<div id="canvasContainer"></div>

<div id="help">
  1 finger: rotate<br>
  2 fingers: pan<br>
  pinch: zoom
</div>

<!-- three.js r180 as ES modules -->
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js";
import { STLLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/STLLoader.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/OBJLoader.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/GLTFLoader.js";

const statusEl = document.getElementById("status");
const chooseBtn = document.getElementById("chooseBtn");
const fileInput = document.getElementById("fileInput");
const canvasContainer = document.getElementById("canvasContainer");

// --- Scene setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.01,
  1000
);
camera.position.set(1,1,1);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio || 1);
canvasContainer.appendChild(renderer.domElement);

// Lights
const hemi = new THREE.HemisphereLight(0xffffff,0x222222,1);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,1);
dir.position.set(1,1,1);
scene.add(dir);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.screenSpacePanning = true;
controls.minDistance = 0.001;
controls.maxDistance = 1000;

// Current model ref
let currentObject = null;

function clearCurrentObject(){
  if(!currentObject) return;
  scene.remove(currentObject);
  currentObject.traverse?.(c=>{
    if(c.isMesh){
      c.geometry?.dispose?.();
      if(c.material){
        if(Array.isArray(c.material)){
          c.material.forEach(m=>m.dispose?.());
        } else {
          c.material.dispose?.();
        }
      }
    }
  });
  currentObject = null;
}

// Center model and move camera so it's nicely framed
function fitCameraToObject(object){
  const box = new THREE.Box3().setFromObject(object);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);

  // avoid NaN / zero
  if(size.x===0 && size.y===0 && size.z===0){
    size.set(0.01,0.01,0.01);
  }

  // recenter object at origin
  object.position.sub(center);

  const maxDim = Math.max(size.x,size.y,size.z);
  const fov = camera.fov * (Math.PI/180);
  let dist = maxDim / (2 * Math.tan(fov/2));
  dist *= 1.5; // padding

  // don't go too close, even for tiny files
  if(dist < 0.05) dist = 0.05;

  camera.position.set(dist, dist, dist);
  camera.lookAt(0,0,0);
  controls.target.set(0,0,0);
  controls.update();
}

// Parsers
function parseSTL(buf){
  const loader = new STLLoader();
  const geom = loader.parse(buf);
  const mat = new THREE.MeshStandardMaterial({
    color:0xcccccc,
    metalness:0.1,
    roughness:0.7
  });
  const mesh = new THREE.Mesh(geom,mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function parseOBJ(txt){
  const loader = new OBJLoader();
  const obj = loader.parse(txt);
  obj.traverse(c=>{
    if(c.isMesh && !c.material){
      c.material = new THREE.MeshStandardMaterial({
        color:0xcccccc,
        metalness:0.1,
        roughness:0.7
      });
    }
    if(c.isMesh){
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
  return obj;
}

function parseGLTF(buf){
  return new Promise((resolve,reject)=>{
    const loader = new GLTFLoader();
    const blob = new Blob([buf]);
    const url = URL.createObjectURL(blob);
    loader.load(
      url,
      gltf=>{
        URL.revokeObjectURL(url);
        resolve(gltf.scene);
      },
      undefined,
      err=>{
        URL.revokeObjectURL(url);
        reject(err);
      }
    );
  });
}

// High-level: take a File and show it
async function loadAndDisplayFile(file){
  statusEl.textContent = `Loading "${file.name}" (${file.size} bytes)...`;
  clearCurrentObject();

  const lower = file.name.toLowerCase();

  try{
    if(lower.endsWith(".stl")){
      const buf = await file.arrayBuffer();
      currentObject = parseSTL(buf);
    } else if(lower.endsWith(".obj")){
      const txt = await file.text();
      currentObject = parseOBJ(txt);
    } else if(lower.endsWith(".gltf") || lower.endsWith(".glb")){
      const buf = await file.arrayBuffer();
      currentObject = await parseGLTF(buf);
    } else {
      statusEl.textContent = `Unsupported file type for "${file.name}"`;
      return;
    }

    scene.add(currentObject);
    fitCameraToObject(currentObject);

    statusEl.textContent = `Loaded "${file.name}" (${file.size} bytes)`;
  }catch(err){
    console.error(err);
    statusEl.textContent = `Failed to load "${file.name}"`;
    alert("Error loading model");
  }
}

// Button opens picker
chooseBtn.addEventListener("click", () => {
  // reset so you can pick the same file twice
  fileInput.value = "";
  statusEl.textContent = "Opening picker...";
  fileInput.click();
});

// When a file is chosen
fileInput.addEventListener("change", () => {
  const count = fileInput.files.length;
  if(count === 0){
    statusEl.textContent = "Picker closed, no file.";
    return;
  }
  const f = fileInput.files[0];
  statusEl.textContent = `Got "${f.name}" (${f.size} bytes)`;
  loadAndDisplayFile(f);
});

// Resize
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Render loop
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}
animate();

console.log("THREE.REVISION =", THREE.REVISION);
</script>

</body>
</html>
