<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>3D Viewer FINAL</title>
<style>
  html,body{
    margin:0;
    height:100%;
    background:#111;
    color:#fff;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
    overflow:hidden;
  }

  #topbar{
    position:absolute;
    top:0;
    left:0;
    right:0;
    background:rgba(0,0,0,0.7);
    padding:.75rem 1rem;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    gap:.75rem;
    z-index:10;
    backdrop-filter:blur(6px);
    -webkit-backdrop-filter:blur(6px);
  }

  .btn{
    background:#2a2a2a;
    border:1px solid #444;
    border-radius:6px;
    padding:.6rem .8rem;
    font-size:.9rem;
    font-weight:500;
    color:#fff;
    line-height:1.2;
    cursor:pointer;
    -webkit-tap-highlight-color: rgba(255,255,255,0.2);
  }

  #status{
    font-size:.8rem;
    color:#9e9e9e;
    line-height:1.4;
    word-break:break-word;
    flex:1;
    min-width:200px;
    max-width:70%;
  }

  #canvasContainer{
    position:absolute;
    inset:0;
  }

  #help{
    position:absolute;
    left:.75rem;
    bottom:.75rem;
    background:rgba(0,0,0,0.6);
    color:#ccc;
    font-size:.7rem;
    line-height:1.4;
    padding:.5rem .6rem;
    border-radius:4px;
    border:1px solid rgba(255,255,255,0.1);
    z-index:10;
  }

  /* input is in layout (so iOS doesn't block it), but visually almost gone */
  #fileInput{
    opacity:0;
    position:absolute;
    left:0;
    top:0;
    width:1px;
    height:1px;
    font-size:16px; /* iOS: prevents zoom */
  }
</style>
</head>
<body>

<div id="topbar">
  <button id="chooseBtn" class="btn">Choose 3D file</button>
  <button id="loadBtn"   class="btn">Load</button>
  <div id="status">No file loaded</div>

  <input id="fileInput" type="file" />
</div>

<div id="canvasContainer"></div>

<div id="help">
  1 finger: rotate<br>
  2 fingers: pan<br>
  pinch: zoom
</div>

<script type="module">
/*
  We wrap everything in a try/catch and if ANYTHING fails
  (imports, etc.), we show it in #status so you see it immediately.
*/
const statusEl   = document.getElementById("status");
const chooseBtn  = document.getElementById("chooseBtn");
const loadBtn    = document.getElementById("loadBtn");
const fileInput  = document.getElementById("fileInput");
const container  = document.getElementById("canvasContainer");

// global-ish vars populated after imports succeed
let THREE, OrbitControls, STLLoader, OBJLoader, GLTFLoader;
let scene, camera, renderer, controls;
let currentObject = null;

// keep last picked file so Load can use it
let selectedFile = null;

async function initThree() {
  try {
    // dynamic import so if CDN fails, we can tell you
    const threeMod = await import("https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js");
    const orbitMod = await import("https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js");
    const stlMod   = await import("https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/STLLoader.js");
    const objMod   = await import("https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/OBJLoader.js");
    const gltfMod  = await import("https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/GLTFLoader.js");

    THREE         = threeMod;
    OrbitControls = orbitMod.OrbitControls;
    STLLoader     = stlMod.STLLoader;
    OBJLoader     = objMod.OBJLoader;
    GLTFLoader    = gltfMod.GLTFLoader;

    setupScene();
    statusEl.textContent = "three.js loaded. Ready.";
  } catch (err) {
    console.error("IMPORT ERROR", err);
    statusEl.textContent = "SCRIPT IMPORT FAILED: " + err;
  }
}

function setupScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.01,
    1000
  );
  camera.position.set(1,1,1);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xffffff,0x222222,1);
  scene.add(hemi);

  const dir = new THREE.DirectionalLight(0xffffff,1);
  dir.position.set(1,1,1);
  scene.add(dir);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.screenSpacePanning = true;
  controls.minDistance = 0.001;
  controls.maxDistance = 1000;

  window.addEventListener("resize", onResize);
  animate();
}

function onResize(){
  if (!camera || !renderer) return;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
  requestAnimationFrame(animate);
  if (controls) controls.update();
  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

function clearCurrentObject(){
  if(!currentObject) return;
  scene.remove(currentObject);
  currentObject.traverse?.(c=>{
    if(c.isMesh){
      c.geometry?.dispose?.();
      if(c.material){
        if(Array.isArray(c.material)){
          c.material.forEach(m=>m.dispose?.());
        } else {
          c.material.dispose?.();
        }
      }
    }
  });
  currentObject = null;
}

function fitCameraToObject(object){
  const box   = new THREE.Box3().setFromObject(object);
  const size  = new THREE.Vector3();
  const center= new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);

  if(size.x===0 && size.y===0 && size.z===0){
    size.set(0.01,0.01,0.01);
  }

  object.position.sub(center);

  const maxDim = Math.max(size.x,size.y,size.z);
  const fov    = camera.fov * (Math.PI/180);
  let dist     = maxDim / (2 * Math.tan(fov/2));
  dist        *= 1.5;
  if(dist < 0.05) dist = 0.05;

  camera.position.set(dist,dist,dist);
  camera.lookAt(0,0,0);
  controls.target.set(0,0,0);
  controls.update();
}

function parseSTL(buf){
  const loader = new STLLoader();
  const geom   = loader.parse(buf);
  const mat    = new THREE.MeshStandardMaterial({
    color:0xcccccc,
    metalness:0.1,
    roughness:0.7
  });
  const mesh   = new THREE.Mesh(geom, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function parseOBJ(txt){
  const loader = new OBJLoader();
  const obj    = loader.parse(txt);
  obj.traverse(c=>{
    if(c.isMesh && !c.material){
      c.material = new THREE.MeshStandardMaterial({
        color:0xcccccc,
        metalness:0.1,
        roughness:0.7
      });
    }
    if(c.isMesh){
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
  return obj;
}

function parseGLTF(buf){
  return new Promise((resolve,reject)=>{
    const loader = new GLTFLoader();
    const blob   = new Blob([buf]);
    const url    = URL.createObjectURL(blob);
    loader.load(
      url,
      gltf=>{
        URL.revokeObjectURL(url);
        resolve(gltf.scene);
      },
      undefined,
      err=>{
        URL.revokeObjectURL(url);
        reject(err);
      }
    );
  });
}

async function loadAndDisplayFile(file){
  if(!file){
    statusEl.textContent = "No file selected to load.";
    return;
  }

  if(!THREE){
    statusEl.textContent = "three.js not ready (imports failed)";
    return;
  }

  statusEl.textContent = `Loading "${file.name}" (${file.size} bytes)...`;

  clearCurrentObject();

  const lower = file.name.toLowerCase();
  try {
    if(lower.endsWith(".stl")){
      const buf = await file.arrayBuffer();
      currentObject = parseSTL(buf);
    } else if(lower.endsWith(".obj")){
      const txt = await file.text();
      currentObject = parseOBJ(txt);
    } else if(lower.endsWith(".gltf") || lower.endsWith(".glb")){
      const buf = await file.arrayBuffer();
      currentObject = await parseGLTF(buf);
    } else {
      statusEl.textContent = `Unsupported file type for "${file.name}"`;
      return;
    }

    scene.add(currentObject);
    fitCameraToObject(currentObject);

    statusEl.textContent = `Loaded "${file.name}" (${file.size} bytes)`;
  } catch (err) {
    console.error("LOAD ERROR", err);
    statusEl.textContent = `Failed to load "${file.name}": ${err}`;
  }
}

/* --------------------
   EVENT WIRING
   -------------------- */

// 1. User clicks "Choose 3D file"
chooseBtn.addEventListener("click", () => {
  // reset so user can choose same file again
  fileInput.value = "";
  statusEl.textContent = "Opening picker...";
  // Try programmatic click. On iOS this sometimes fails silently,
  // BUT the user can still tap directly on the invisible input area
  // (top-left corner). We'll give them that fallback.
  fileInput.click();
});

// 2. After file chosen
fileInput.addEventListener("change", () => {
  const count = fileInput.files.length;
  if(count === 0){
    statusEl.textContent = "Picker closed, 0 files.";
    selectedFile = null;
    return;
  }

  selectedFile = fileInput.files[0];

  statusEl.textContent =
    `Chosen: "${selectedFile.name}" (${selectedFile.size} bytes). Press Load.`;
});

// 3. User clicks Load to actually parse and render
loadBtn.addEventListener("click", () => {
  if(!selectedFile){
    statusEl.textContent = "No file selected yet.";
    return;
  }
  loadAndDisplayFile(selectedFile);
});

/* --------------------
   INIT
   -------------------- */
statusEl.textContent = "Loading three.jsâ€¦";
initThree();
</script>

</body>
</html>
