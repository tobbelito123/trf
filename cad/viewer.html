<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>3D Viewer</title>
<style>
  html,body{
    margin:0;
    height:100%;
    background:#111;
    color:#fff;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
    overflow:hidden;
  }

  #topbar{
    position:absolute;
    top:0;
    left:0;
    right:0;
    background:rgba(0,0,0,0.7);
    padding:.75rem 1rem;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    gap:.75rem;
    z-index:10;
    backdrop-filter:blur(6px);
    -webkit-backdrop-filter:blur(6px);
  }

  /* style both the label-button and the real button the same */
  .btnLike{
    background:#2a2a2a;
    border:1px solid #444;
    border-radius:6px;
    padding:.6rem .8rem;
    font-size:.9rem;
    font-weight:500;
    color:#fff;
    line-height:1.2;
    cursor:pointer;
    -webkit-tap-highlight-color:rgba(255,255,255,0.2);
    display:inline-block;
  }

  #status{
    font-size:.8rem;
    color:#9e9e9e;
    line-height:1.4;
    word-break:break-word;
    flex:1;
    min-width:200px;
    max-width:70%;
  }

  #canvasContainer{
    position:absolute;
    inset:0;
  }

  #help{
    position:absolute;
    left:.75rem;
    bottom:.75rem;
    background:rgba(0,0,0,0.6);
    color:#ccc;
    font-size:.7rem;
    line-height:1.4;
    padding:.5rem .6rem;
    border-radius:4px;
    border:1px solid rgba(255,255,255,0.1);
    z-index:10;
  }

  /* IMPORTANT:
     The input MUST be in the DOM, not display:none.
     We'll keep it tiny/transparent at top-left.
  */
  #fileInput{
    position:absolute;
    left:0;
    top:0;
    width:1px;
    height:1px;
    opacity:0;
    font-size:16px; /* avoid iOS zoom */
  }
</style>
</head>
<body>

<div id="topbar">
  <!-- This label opens the native picker because it's bound to #fileInput -->
  <label for="fileInput" class="btnLike" id="chooseLabel">Choose 3D file</label>

  <!-- This is a real button for loading after selection -->
  <button id="loadBtn" class="btnLike" type="button">Load</button>

  <div id="status">No file loaded</div>

  <input id="fileInput" type="file" />
</div>

<div id="canvasContainer"></div>
<div id="help">1 finger: rotate<br>2 fingers: pan<br>pinch: zoom</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js";
import { STLLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/STLLoader.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/OBJLoader.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/GLTFLoader.js";

const statusEl   = document.getElementById("status");
const loadBtn    = document.getElementById("loadBtn");
const fileInput  = document.getElementById("fileInput");
const container  = document.getElementById("canvasContainer");

let scene, camera, renderer, controls;
let currentObject = null;
let selectedFile = null;

// ---- three.js scene setup ----
scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.01,
  1000
);
camera.position.set(1,1,1);

renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio || 1);
container.appendChild(renderer.domElement);

// lights
const hemi = new THREE.HemisphereLight(0xffffff,0x222222,1);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,1);
dir.position.set(1,1,1);
scene.add(dir);

// controls
controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.screenSpacePanning = true;
controls.minDistance = 0.001;
controls.maxDistance = 1000;

// ---- helpers ----
function clearCurrentObject(){
  if(!currentObject) return;
  scene.remove(currentObject);
  currentObject.traverse?.(c=>{
    if(c.isMesh){
      c.geometry?.dispose?.();
      if(c.material){
        if(Array.isArray(c.material)){
          c.material.forEach(m=>m.dispose?.());
        } else {
          c.material.dispose?.();
        }
      }
    }
  });
  currentObject = null;
}

function fitCameraToObject(object){
  const box = new THREE.Box3().setFromObject(object);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);

  if(size.x===0 && size.y===0 && size.z===0){
    size.set(0.01,0.01,0.01);
  }

  object.position.sub(center);

  const maxDim = Math.max(size.x,size.y,size.z);
  const fov = camera.fov * (Math.PI / 180);
  let dist = maxDim / (2 * Math.tan(fov / 2));
  dist *= 1.5;
  if(dist < 0.05) dist = 0.05;

  camera.position.set(dist, dist, dist);
  camera.lookAt(0,0,0);
  controls.target.set(0,0,0);
  controls.update();
}

function parseSTL(buf){
  const loader = new STLLoader();
  const geom = loader.parse(buf);
  const mat = new THREE.MeshStandardMaterial({
    color:0xcccccc,
    metalness:0.1,
    roughness:0.7
  });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function parseOBJ(txt){
  const loader = new OBJLoader();
  const obj = loader.parse(txt);
  obj.traverse(c=>{
    if(c.isMesh && !c.material){
      c.material = new THREE.MeshStandardMaterial({
        color:0xcccccc,
        metalness:0.1,
        roughness:0.7
      });
    }
    if(c.isMesh){
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
  return obj;
}

function parseGLTF(buf){
  return new Promise((resolve,reject)=>{
    const loader = new GLTFLoader();
    const blob = new Blob([buf]);
    const url = URL.createObjectURL(blob);
    loader.load(
      url,
      gltf=>{
        URL.revokeObjectURL(url);
        resolve(gltf.scene);
      },
      undefined,
      err=>{
        URL.revokeObjectURL(url);
        reject(err);
      }
    );
  });
}

async function loadAndDisplayFile(file){
  if(!file){
    statusEl.textContent = "No file selected.";
    return;
  }
  statusEl.textContent = `Loading "${file.name}" (${file.size} bytes)...`;

  clearCurrentObject();

  const lower = file.name.toLowerCase();

  try{
    if(lower.endsWith(".stl")){
      const buf = await file.arrayBuffer();
      currentObject = parseSTL(buf);
    }else if(lower.endsWith(".obj")){
      const txt = await file.text();
      currentObject = parseOBJ(txt);
    }else if(lower.endsWith(".gltf") || lower.endsWith(".glb")){
      const buf = await file.arrayBuffer();
      currentObject = await parseGLTF(buf);
    }else{
      statusEl.textContent = `Unsupported file type for "${file.name}"`;
      return;
    }

    scene.add(currentObject);
    fitCameraToObject(currentObject);

    statusEl.textContent = `Loaded "${file.name}" (${file.size} bytes)`;
  }catch(e){
    console.error(e);
    statusEl.textContent = `Error loading "${file.name}": ${e}`;
  }
}

// ---- events ----

// 1. User picks a file via label/input.
//    We DO NOT call .click() in JS at all.
//    After the picker closes, we cache the file but don't load yet.
fileInput.addEventListener("change", () => {
  if(!fileInput.files.length){
    statusEl.textContent = "Picker closed.";
    selectedFile = null;
    return;
  }
  selectedFile = fileInput.files[0];
  statusEl.textContent = `Chosen: "${selectedFile.name}" (${selectedFile.size} bytes). Press Load.`;
});

// 2. User presses Load to actually render the chosen file
loadBtn.addEventListener("click", () => {
  if(!selectedFile){
    statusEl.textContent = "No file chosen yet.";
    return;
  }
  loadAndDisplayFile(selectedFile);
});

// resize + render loop
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}
animate();

// init status
statusEl.textContent = `Ready (three.js r${THREE.REVISION})`;
console.log("THREE.REVISION =", THREE.REVISION);
</script>

</body>
</html>
