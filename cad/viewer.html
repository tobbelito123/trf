<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>3D Viewer</title>
<style>
  html,body{
    margin:0;
    height:100%;
    background:#111;
    color:#fff;
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
    overflow:hidden;
  }

  #topbar{
    position:absolute;
    top:0;
    left:0;
    right:0;
    background:rgba(0,0,0,0.7);
    padding:.75rem 1rem;
    display:flex;
    flex-wrap:wrap;
    align-items:flex-start;
    gap:.75rem;
    z-index:10;
    backdrop-filter:blur(6px);
    -webkit-backdrop-filter:blur(6px);
  }

  /* we use a label styled as button */
  .fileLabelBtn{
    background:#2a2a2a;
    border:1px solid #444;
    border-radius:6px;
    padding:.6rem .8rem;
    font-size:.9rem;
    font-weight:500;
    color:#fff;
    line-height:1.2;
    cursor:pointer;
    -webkit-tap-highlight-color: rgba(255,255,255,0.2);
  }

  #status{
    font-size:.8rem;
    color:#9e9e9e;
    line-height:1.4;
    word-break:break-word;
    flex:1;
    min-width:200px;
    max-width:70%;
  }

  #canvasContainer{
    position:absolute;
    inset:0;
  }

  #help{
    position:absolute;
    left:.75rem;
    bottom:.75rem;
    background:rgba(0,0,0,0.6);
    color:#ccc;
    font-size:.7rem;
    line-height:1.4;
    padding:.5rem .6rem;
    border-radius:4px;
    border:1px solid rgba(255,255,255,0.1);
    z-index:10;
  }

  /*
    IMPORTANT:
    The input must be in the DOM, not display:none.
    We'll keep it tiny and transparent, but still
    physically present so iOS is happy.
  */
  #fileInput{
    opacity:0;
    width:1px;
    height:1px;
    position:absolute;
    left:0;
    top:0;
  }
</style>
</head>
<body>

<div id="topbar">
  <!-- label triggers the hidden-looking input -->
  <label for="fileInput" class="fileLabelBtn">Choose 3D file</label>

  <div id="status">No file loaded</div>

  <input id="fileInput" type="file" />
</div>

<div id="canvasContainer"></div>

<div id="help">
  1 finger: rotate<br>
  2 fingers: pan<br>
  pinch: zoom
</div>

<!-- three.js r180 as ES modules -->
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js";
import { STLLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/STLLoader.js";
import { OBJLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/OBJLoader.js";
import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/GLTFLoader.js";

const statusEl   = document.getElementById("status");
const fileInput  = document.getElementById("fileInput");
const container  = document.getElementById("canvasContainer");

// --- Scene setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.01,
  1000
);
camera.position.set(1,1,1);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio || 1);
container.appendChild(renderer.domElement);

// Lights
const hemi = new THREE.HemisphereLight(0xffffff,0x222222,1);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,1);
dir.position.set(1,1,1);
scene.add(dir);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.screenSpacePanning = true;
controls.minDistance = 0.001;
controls.maxDistance = 1000;

// Track current mesh
let currentObject = null;

function clearCurrentObject(){
  if(!currentObject) return;
  scene.remove(currentObject);
  currentObject.traverse?.(c=>{
    if(c.isMesh){
      c.geometry?.dispose?.();
      if(c.material){
        if(Array.isArray(c.material)){
          c.material.forEach(m=>m.dispose?.());
        } else {
          c.material.dispose?.();
        }
      }
    }
  });
  currentObject = null;
}

// Position camera around loaded object
function fitCameraToObject(object){
  const box = new THREE.Box3().setFromObject(object);
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();
  box.getSize(size);
  box.getCenter(center);

  // Avoid zero-size causing NaN
  if(size.x===0 && size.y===0 && size.z===0){
    size.set(0.01,0.01,0.01);
  }

  // Move model so that its center is at (0,0,0)
  object.position.sub(center);

  // Distance so model fits view
  const maxDim = Math.max(size.x,size.y,size.z);
  const fov = camera.fov * (Math.PI/180);
  let dist = maxDim / (2 * Math.tan(fov/2));
  dist *= 1.5;

  if(dist < 0.05) dist = 0.05;

  camera.position.set(dist, dist, dist);
  camera.lookAt(0,0,0);
  controls.target.set(0,0,0);
  controls.update();
}

// Converters for each format
function parseSTL(buf){
  const loader = new STLLoader();
  const geom = loader.parse(buf);
  const mat = new THREE.MeshStandardMaterial({
    color:0xcccccc,
    metalness:0.1,
    roughness:0.7
  });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  return mesh;
}

function parseOBJ(txt){
  const loader = new OBJLoader();
  const obj = loader.parse(txt);
  obj.traverse(c=>{
    if(c.isMesh && !c.material){
      c.material = new THREE.MeshStandardMaterial({
        color:0xcccccc,
        metalness:0.1,
        roughness:0.7
      });
    }
    if(c.isMesh){
      c.castShadow = true;
      c.receiveShadow = true;
    }
  });
  return obj;
}

function parseGLTF(buf){
  return new Promise((resolve,reject)=>{
    const loader = new GLTFLoader();
    const blob = new Blob([buf]);
    const url  = URL.createObjectURL(blob);
    loader.load(
      url,
      gltf=>{
        URL.revokeObjectURL(url);
        resolve(gltf.scene);
      },
      undefined,
      err=>{
        URL.revokeObjectURL(url);
        reject(err);
      }
    );
  });
}

// Load file -> render
async function loadAndDisplayFile(file){
  statusEl.textContent = `Loading "${file.name}" (${file.size} bytes)...`;

  clearCurrentObject();

  const lower = file.name.toLowerCase();
  try{
    if(lower.endsWith(".stl")){
      const buf = await file.arrayBuffer();
      currentObject = parseSTL(buf);
    } else if(lower.endsWith(".obj")){
      const txt = await file.text();
      currentObject = parseOBJ(txt);
    } else if(lower.endsWith(".gltf") || lower.endsWith(".glb")){
      const buf = await file.arrayBuffer();
      currentObject = await parseGLTF(buf);
    } else {
      statusEl.textContent = `Unsupported file type for "${file.name}"`;
      return;
    }

    scene.add(currentObject);
    fitCameraToObject(currentObject);

    statusEl.textContent = `Loaded "${file.name}" (${file.size} bytes)`;
  }catch(err){
    console.error(err);
    statusEl.textContent = `Failed to load "${file.name}"`;
    alert("Error loading model");
  }
}

// When user selects a file (this is the ONLY event flow now)
fileInput.addEventListener("change", () => {
  const count = fileInput.files.length;
  if(count === 0){
    statusEl.textContent = "Picker closed, no file.";
    return;
  }
  const f = fileInput.files[0];
  statusEl.textContent = `Got "${f.name}" (${f.size} bytes)`;
  loadAndDisplayFile(f);
});

// Handle screen resize
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animation/render loop
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
}
animate();

console.log("THREE.REVISION =", THREE.REVISION);
</script>

</body>
</html>
